# 协议

## tcp ip 三次握手，四次挥手

握手的时候，A和B打个招呼，B可以直接把自己的SYN信息和对A的回应ACK信息一起带上，但是挥手的时候，A说我要断开了，B还没发完最后的数据，因此需要先回应一下A，我收到你的断开的请求了，但是你要等我把最后的内容给你，所以这里分开了2步：
（1）回应A；
（2）发送自己的最后一个数据

## socket 通信

## 浏览器请求资源过程

## GET POST的区别

- 从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
- 从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。
- 从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。
- 从幂等性的角度，GET是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的)
- 从TCP的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)

## HTTP状态码

- 1xx: 表示目前是协议处理的中间状态，还需要后续操作。
- 2xx: 表示成功状态。
- 3xx: 重定向状态，资源位置发生变动，需要重新请求。
- 4xx: 请求报文有误。
- 5xx: 服务器端发生错误。

200 OK是见得最多的成功状态码。通常在响应体中放有数据。
204 No Content含义与 200 相同，但响应头后没有 body 数据。
206 Partial Content顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段Content-Range。

301 Moved Permanently即永久重定向，对应着302 Found，即临时重定向。
比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。
301 应用场景：
1、http跳https,
（2、二级域名跳转到主域名，abc.com 到 www.adc.com）
3、404跳转到新页面。
4、老域名跳新域名。

而如果只是暂时不可用，那么直接返回302即可，和301不同的是，浏览器并不会做缓存优化。
304 Not Modified: 当协商缓存命中时会返回这个状态码。详见浏览器缓存

## HTTP缺点

1、无状态。

2、明文传输，不使用二进制数据，而是文本形式

3、队头阻塞问题。
当http开启长连接时，公用一个TCP连接，同一个时刻只能处理一个请求。当一个过长的时候，其他处于阻塞状态。

## HTTP代理

1、负载均衡 代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。

2、保障安全 

3、缓存代理

## HTTP缓存以及代理缓存

## SSR CSR

客户端在不同网络环境下进行数据请求，客户端需要经历从js加载完成到数据请求再到页面渲染这个时间段。导致了大量时间消耗以及浏览器性能消耗。
服务端在内网请求，数据响应快，不需要等待js代码加载，可以先请求数据，再渲染可视部分然后返回给客户端，客户端再做二次渲染，这样大部分消耗的就是服务端的性能。

SSR解决的问题就两点：
1、利于SEO优化
搜索引擎爬虫一般是全文分析的模式，分析内容涵盖了一个网站主要3个部分的内容:文本、多媒体(主要是图片)和外部链接。
搜索引擎并不能收录到 ajax 爬取数据之后然后再动态 js 渲染出来的页面。
而服务端渲染的页面代码都可以在源代码中看到，这有助于搜索引擎识别

2、首屏加载快
客户端渲染下，除了加载html,还要等待js/css加载完成，之后执行js渲染出页面，这个期间用户一直在等待，而服务端只需要加载当前页面的内容，而不需要一次性加载全部的 js 文件。等待时间大大缩短，首屏加载变快。
